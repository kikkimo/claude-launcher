#!/usr/bin/env node

/**
 * Claude Launcher - Refactored modular version
 * A launcher for Claude Code with third-party API support
 */

const ApiManager = require('./lib/api-manager');
const Menu = require('./lib/ui/menu');
const colors = require('./lib/ui/colors');
const {
    waitForKey,
    promptForThirdPartyApi,
    confirmAction,
    showSuccess,
    showError,
    showInfo
} = require('./lib/ui/prompts');
const {
    launchClaudeDefault,
    launchClaudeSkipPermissions,
    launchClaudeWithApi
} = require('./lib/launcher');
const { getPasswordInput } = require('./lib/auth/password-input');
const { verifyExportPassword, setupNewPassword, changePassword: changePasswordModule } = require('./lib/auth/password-validator');
const { maskApiToken } = require('./lib/validators');
const { showApiSelectionTable, confirmDeletion } = require('./lib/ui/interactive-table');
const i18n = require('./lib/i18n');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { exec } = require('child_process');

// Initialize components
const apiManager = new ApiManager();

// Global menu objects to prevent screen flickering during navigation
let globalMainMenu = null;
let globalConfirmMenu = null;
let globalApiManagementMenu = null;

/**
 * Initialize global menu objects to prevent recreation and screen flickering
 */
function initializeGlobalMenus() {
    if (!globalMainMenu) {
        globalMainMenu = new Menu();
    }
    if (!globalConfirmMenu) {
        globalConfirmMenu = new Menu();
    }
    if (!globalApiManagementMenu) {
        globalApiManagementMenu = new Menu();
    }
}

/**
 * Get export directory path and create if not exists
 * @returns {string} - Export directory path
 */
function getExportDirectory() {
    const userHome = os.homedir();
    const exportDir = path.join(userHome, 'claude-launcher');

    // Create directory if it doesn't exist
    if (!fs.existsSync(exportDir)) {
        fs.mkdirSync(exportDir, { recursive: true });
    }

    return exportDir;
}

/**
 * Generate timestamp-based filename for export
 * @returns {string} - Filename with timestamp
 */
function generateExportFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
                     (now.getMonth() + 1).toString().padStart(2, '0') +
                     now.getDate().toString().padStart(2, '0') +
                     now.getHours().toString().padStart(2, '0') +
                     now.getMinutes().toString().padStart(2, '0') +
                     now.getSeconds().toString().padStart(2, '0');

    return `claude-launcher-export-${timestamp}.json`;
}

/**
 * Open file with system default application
 * @param {string} filePath - Path to the file to open
 */
function openFileWithDefault(filePath) {
    const platform = process.platform;
    let command;

    if (platform === 'win32') {
        command = `start "" "${filePath}"`;
    } else if (platform === 'darwin') {
        command = `open "${filePath}"`;
    } else {
        command = `xdg-open "${filePath}"`;
    }

    exec(command, (error) => {
        if (error) {
            console.log(colors.yellow + `Could not open file automatically: ${error.message}` + colors.reset);
        }
    });
}

/**
 * Validate import file path and JSON format
 * @param {string} filePath - Path to the JSON file
 * @returns {Object} - Validation result with success status and data/error
 */
function validateImportFile(filePath) {
    const result = {
        valid: false,
        data: null,
        error: null
    };

    try {
        // Check if file path is provided
        if (!filePath || filePath.trim() === '') {
            result.error = 'File path cannot be empty';
            return result;
        }

        // Normalize and resolve path
        const normalizedPath = path.resolve(filePath.trim());

        // Check if file exists
        if (!fs.existsSync(normalizedPath)) {
            result.error = i18n.tSync('errors.file.file_not_found', normalizedPath);
            return result;
        }

        // Check if it's a file (not directory)
        const stats = fs.statSync(normalizedPath);
        if (!stats.isFile()) {
            result.error = `Path is not a file: ${normalizedPath}`;
            return result;
        }

        // Check file extension
        if (path.extname(normalizedPath).toLowerCase() !== '.json') {
            result.error = `File must have .json extension: ${normalizedPath}`;
            return result;
        }

        // Read and parse JSON file
        const fileContent = fs.readFileSync(normalizedPath, 'utf8');

        // Validate JSON format
        let jsonData;
        try {
            jsonData = JSON.parse(fileContent);
        } catch (parseError) {
            result.error = `Invalid JSON format: ${parseError.message}`;
            return result;
        }

        // Basic structure validation for claude-launcher config
        if (!jsonData || typeof jsonData !== 'object') {
            result.error = 'JSON file must contain a valid configuration object';
            return result;
        }

        // Check for required fields (basic validation)
        if (!jsonData.hasOwnProperty('apis') || !Array.isArray(jsonData.apis)) {
            result.error = i18n.tSync('errors.file.invalid_format', 'JSON file must contain an "apis" array');
            return result;
        }

        result.valid = true;
        result.data = fileContent; // Return raw JSON string for compatibility
        return result;

    } catch (error) {
        result.error = `File validation error: ${error.message}`;
        return result;
    }
}

// Main menu options - will be populated dynamically with i18n
let menuOptions = [];

/**
 * Add new third-party API
 */
async function addNewThirdPartyApi() {
    try {
        const apiData = await promptForThirdPartyApi();

        // Check if this is the first API
        const isFirstApi = apiManager.getApis().length === 0;
        const hasExportPassword = apiManager.hasExportPassword();

        const newApi = apiManager.addApi(
            apiData.baseUrl,
            apiData.authToken,
            apiData.model,
            apiData.name,
            apiData.provider
        );

        showSuccess(await i18n.t('messages.success.api_added'), [
            `Name: ${newApi.name}`,
            `${await i18n.t('api.details.provider')}: ${newApi.provider}`,
            `${await i18n.t('api.details.url')}: ${newApi.baseUrl}`,
            `${await i18n.t('api.details.model')}: ${newApi.model}`
        ]);

        if (isFirstApi) {
            showInfo(await i18n.t('messages.info.first_time_usage'));
        }

    } catch (error) {
        // Check if user cancelled the operation
        const cancelledMessage = await i18n.t('errors.general.cancelled_by_user');
        if (error.message === cancelledMessage) {
            // User cancelled - show neutral message instead of error
            console.log(colors.yellow + await i18n.t('messages.info.operation_cancelled') + colors.reset);
        } else {
            // Actual error occurred
            showError(await i18n.t('errors.api.failed_add', error.message));
        }
    }

    await waitForKey(await i18n.t('messages.prompts.press_any_key'));
}

/**
 * Remove third-party API
 */
async function removeThirdPartyApi() {
    try {
        while (true) {
            // Get fresh API list each iteration
            const apis = apiManager.getApis();
            const activeApi = apiManager.getActiveApi();
            const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

            // Show API selection table (handles no APIs case internally)
            const selectedApi = await showApiSelectionTable(
                apis,
                i18n.tSync('ui.general.select_api_remove'),
                'remove',
                activeIndex
            );

            if (!selectedApi) {
                return showMenu();
            }

            // Show confirmation dialog
            const confirmed = await confirmDeletion(selectedApi);

            if (confirmed) {
                try {
                    // Find the index of the selected API in the current list
                    const selectedIndex = apis.findIndex(api => api.id === selectedApi.id);
                    apiManager.removeApi(selectedIndex);

                    console.clear();
                    showSuccess(await i18n.t('messages.success.api_removed'), [
                        `${await i18n.t('api.actions.removed_info', selectedApi.name)}`,
                        `${await i18n.t('api.details.provider')}: ${selectedApi.provider}`
                    ]);

                    // Check if there are more APIs to remove
                    const remainingApis = apiManager.getApis();
                    if (remainingApis.length === 0) {
                        showInfo(await i18n.t('messages.info.all_apis_removed'));
                        await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                        return showMenu();
                    } else {
                        await waitForKey(await i18n.t('messages.prompts.press_any_key_remove'));
                        // Continue the loop to show updated list
                    }

                } catch (removeError) {
                    showError(await i18n.t('errors.api.failed_remove', removeError.message));
                    await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                    return showMenu();
                }
            } else {
                showInfo(await i18n.t('messages.info.removal_cancelled'));
                await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                // Continue the loop to show the list again
            }
        }

    } catch (error) {
        showError('Failed to remove API', [error.message]);
        await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
    }
}

/**
 * Switch active third-party API
 */
async function switchThirdPartyApi() {
    try {
        const apis = apiManager.getApis();
        const activeApi = apiManager.getActiveApi();
        const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

        // Áé∞Âú®Ë°®Ê†ºÂáΩÊï∞ÂÜÖÈÉ®Â§ÑÁêÜÊï¥‰∏™ÂàáÊç¢ÊµÅÁ®ã
        const selectedApi = await showApiSelectionTable(
            apis,
            i18n.tSync('api.actions.select_to_switch'),
            'switch',
            activeIndex,
            apiManager  // ‰º†ÈÄí apiManager ËÆ©Ë°®Ê†ºÂáΩÊï∞Â§ÑÁêÜÂàáÊç¢ÈÄªËæë
        );

        // Ë°®Ê†ºÂáΩÊï∞Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÊâÄÊúâÊòæÁ§∫ÂíåÂàáÊç¢ÈÄªËæëÔºåÁõ¥Êé•ËøîÂõû‰∏ªËèúÂçï
        return showMenu();

    } catch (error) {
        showError(await i18n.t('errors.api.failed_switch', error.message));
        await waitForKey(await i18n.t('messages.prompts.press_any_key'));
        return showMenu();
    }
}

/**
 * View API statistics
 */
async function viewStatistics() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üìä ' + await i18n.t('statistics.title') + colors.reset);
    console.log('');

    const stats = apiManager.getStatistics();
    const apis = apiManager.getApis();

    console.log(colors.cyan + '  ' + i18n.tSync('ui.general.summary') + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.total_apis', stats.totalApis)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.active_api', stats.activeApiName)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.most_used', stats.mostUsedApi)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.total_usage', stats.totalUsage)}` + colors.reset);
    console.log('');

    if (apis.length > 0) {
        console.log(colors.cyan + '  ' + i18n.tSync('ui.general.configured_apis') + colors.reset);

        // Pre-fetch translations to avoid await in forEach
        const currentlyActiveText = await i18n.t('api.details.currently_active');
        const providerText = await i18n.t('api.details.provider');
        const usageText = await i18n.t('api.details.usage');
        const timesSuffixText = await i18n.t('api.details.times_suffix');
        const createdAtText = await i18n.t('api.details.created_at');

        apis.forEach((api, index) => {
            const isActive = apiManager.getActiveApi()?.id === api.id;
            const activeText = isActive ? ` (${currentlyActiveText})` : '';
            console.log(colors.gray + `    ${index + 1}. ${api.name}${activeText}` + colors.reset);
            console.log(colors.dim + `       ${providerText}: ${api.provider}` + colors.reset);
            console.log(colors.dim + `       ${usageText}: ${api.usageCount || 0} ${timesSuffixText}` + colors.reset);
            console.log(colors.dim + `       ${createdAtText}: ${api.createdAt}` + colors.reset);
        });
    }

    console.log('');
    await waitForKey(await i18n.t('messages.prompts.press_any_key'));
}


/**
 * Handle first time password setup
 */
async function handleFirstTimePasswordSetup() {
    while (true) {
        // Clear screen and show header
        console.clear();
        console.log('');
        console.log(colors.bright + colors.yellow + 'üîê ' + i18n.tSync('password.setup.first_time_title') + colors.reset);
        console.log('');

        // Show information
        console.log(colors.cyan + i18n.tSync('password.setup.why_needed') + colors.reset);
        const whyNeededItems = i18n.tSync('password.setup.why_needed_items');
        if (Array.isArray(whyNeededItems)) {
            whyNeededItems.forEach(item => {
                console.log(colors.gray + '‚Ä¢ ' + item + colors.reset);
            });
        }
        console.log('');
        console.log(colors.cyan + 'üîí ' + i18n.tSync('password.setup.new_security_title') + colors.reset);
        const securityItems = i18n.tSync('password.setup.security_items');
        if (Array.isArray(securityItems)) {
            securityItems.forEach(item => {
                console.log(colors.gray + '‚Ä¢ ' + item + colors.reset);
            });
        }
        console.log('');
        console.log(colors.yellow + i18n.tSync('password.setup.options_title') + colors.reset);
        console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('password.setup.option_set') + colors.reset);
        console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('password.setup.option_skip') + colors.reset);
        console.log('');
        console.log(colors.red + i18n.tSync('password.setup.warning_skip') + colors.reset);
        console.log('');

        // Show menu options statically
        console.log(colors.orange + '  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê' + colors.reset);
        console.log(colors.orange + '  ‚îÇ' + colors.white + colors.bright + '           Claude Code Launcher         ' + colors.orange + '‚îÇ' + colors.reset);
        console.log(colors.orange + '  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò' + colors.reset);
        console.log('');
        console.log(colors.gray + '  ' + i18n.tSync('navigation.use_number_keys') + colors.reset);
        console.log('');
        console.log(colors.yellow + '  1. ' + colors.reset + i18n.tSync('password.setup.menu_set_password'));
        console.log(colors.yellow + '  2. ' + colors.reset + i18n.tSync('password.setup.menu_skip_setup'));
        console.log(colors.gray + '  ' + i18n.tSync('password.setup.menu_back') + colors.reset);
        console.log('');

        // Use simple input instead of Menu class to avoid refresh issues
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        const choice = await new Promise((resolve) => {
            rl.question(colors.green + i18n.tSync('navigation.enter_choice_prompt') + colors.reset, (answer) => {
                rl.close();
                resolve(parseInt(answer) - 1);
            });
        });

        switch (choice) {
            case 0: // Set password
                const passwordResult = await promptForPasswordSetup();
                if (passwordResult) {
                    return true; // Password set successfully
                }
                // If password setup failed, continue loop to show menu again
                break;

            case 1: // Skip setup
                const skipResult = await confirmSkipPassword();
                if (skipResult === true) {
                    return true; // Skip confirmed
                } else if (skipResult === 'reconsider') {
                    continue; // Return to main setup menu
                }
                // If skip was canceled, continue loop
                break;

            case 2: // Back to main menu
            default:
                return false; // Exit setup
        }
    }
}

/**
 * Prompt user to set password
 */
async function promptForPasswordSetup() {
    const result = await setupNewPassword(apiManager, true);
    if (result) {
        await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
    }
    return result;
}

/**
 * Confirm skip password setup
 */
async function confirmSkipPassword() {
    console.log('');
    console.log(colors.bright + colors.red + '‚ö†Ô∏è  ' + i18n.tSync('errors.password.confirm_skip_title') + colors.reset);
    console.log('');
    console.log(colors.gray + i18n.tSync('ui.general.after_skipping_password_setup') + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[0] + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[1] + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[2] + colors.reset);
    console.log('');

    // Ensure global menus are initialized
    initializeGlobalMenus();

    globalConfirmMenu.setOptions([
        i18n.tSync('ui.general.confirm_skip_option'),
        i18n.tSync('ui.general.reconsider_option')
    ]);

    const choice = await globalConfirmMenu.navigate();

    if (choice === 0) {
        try {
            apiManager.skipPasswordSetup();
            console.log(colors.yellow + i18n.tSync('errors.password.setup_skipped') + colors.reset);
            await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
            return true;
        } catch (error) {
            console.log(colors.red + `Operation failed: ${error.message}` + colors.reset);
            await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
            return false;
        }
    }

    return 'reconsider'; // Return to password setup main menu
}

/**
 * Show API Management Menu
 */
async function showApiManagementMenu() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üìã ' + await i18n.t('menu.api_management.title') + colors.reset);
    console.log('');

    // Check if this is first time usage and prompt for password setup
    if (apiManager.isFirstTimeUsage()) {
        const passwordChoice = await handleFirstTimePasswordSetup();
        if (!passwordChoice) {
            // User chose to skip or canceled, return to main menu
            return showMenu();
        }
    }

    // Build menu options based on password setup status
    const menuOptions = [
        await i18n.t('menu.api_management.add_new'),
        await i18n.t('menu.api_management.remove'),
        await i18n.t('menu.api_management.switch'),
        await i18n.t('menu.api_management.statistics')
    ];

    // Add import/export options only if password is set
    if (apiManager.canUseImportExport()) {
        menuOptions.push(await i18n.t('menu.api_management.export'));
        menuOptions.push(await i18n.t('menu.api_management.import'));
        menuOptions.push(await i18n.t('menu.api_management.change_password'));
    }

    menuOptions.push(await i18n.t('menu.api_management.back'));

    // Ensure global menus are initialized
    initializeGlobalMenus();

    globalApiManagementMenu.setOptions(menuOptions);

    const choice = await globalApiManagementMenu.navigate();

    // Handle menu choices based on current menu options
    if (choice === 0) { // Add New API
        await addNewThirdPartyApi();
    } else if (choice === 1) { // Remove API
        await removeThirdPartyApi();
    } else if (choice === 2) { // Switch Active API
        await switchThirdPartyApi();
    } else if (choice === 3) { // View API Statistics
        await viewStatistics();
    } else if (apiManager.canUseImportExport()) {
        // If import/export is available, handle those options
        if (choice === 4) { // Export Configuration
            await exportConfiguration();
        } else if (choice === 5) { // Import Configuration
            await importConfiguration();
        } else if (choice === 6) { // Change Password
            await changePassword();
        } else if (choice === 7) { // Back to Main Menu
            return showMenu();
        }
    } else {
        // If import/export is not available, only Back to Main Menu
        if (choice === 4) { // Back to Main Menu
            return showMenu();
        }
    }

    // Return to API management menu after completing action
    showApiManagementMenu();
}

/**
 * Handle third-party API launch
 */
async function handleThirdPartyApiLaunch(skipPermissions = false) {
    try {
        const activeApi = apiManager.getActiveApi();

        if (!activeApi) {
            console.clear();
            showInfo(i18n.tSync('launch.no_active_api'), [
                i18n.tSync('launch.no_active_api_desc'),
                i18n.tSync('launch.add_configure_first')
            ]);

            await waitForKey(i18n.tSync('launch.press_key_return'));
            return showMenu();
        }

        // Increment usage count for the active API since we're actually using it
        apiManager.incrementActiveApiUsage();

        launchClaudeWithApi(activeApi, skipPermissions);

    } catch (error) {
        showError('Failed to launch with third-party API', [error.message]);

        setTimeout(() => {
            showMenu();
        }, 2000);
    }
}

/**
 * Execute selected menu item
 */
async function executeSelection(selectedIndex) {
    switch (selectedIndex) {
        case 0: // Launch Claude Code
            launchClaudeDefault();
            break;

        case 1: // Launch Claude Code (Skip Permissions)
            launchClaudeSkipPermissions();
            break;

        case 2: // Launch Claude Code with 3rd-party API
            await handleThirdPartyApiLaunch(false);
            break;

        case 3: // Launch Claude Code with 3rd-party API (Skip Permissions)
            await handleThirdPartyApiLaunch(true);
            break;

        case 4: // 3rd-party API Management
            await showApiManagementMenu();
            break;

        case 5: // Language Settings
            await showLanguageSettings();
            break;

        case 6: // Exit
            console.log('');
            console.log(colors.green + 'üëã ' + await i18n.t('menu.main.exit') + '!' + colors.reset);
            process.exit(0);
            break;

        default:
            showMenu();
            break;
    }
}

/**
 * Show main menu
 */
async function showMenu() {
    // Ensure global menus are initialized
    initializeGlobalMenus();

    // Populate menu options dynamically with i18n translations
    menuOptions = [
        await i18n.t('menu.main.launch_default'),
        await i18n.t('menu.main.launch_skip'),
        await i18n.t('menu.main.launch_api'),
        await i18n.t('menu.main.launch_api_skip'),
        await i18n.t('menu.main.api_management'),
        await i18n.t('menu.main.language_settings'),
        await i18n.t('menu.main.exit')
    ];

    globalMainMenu.setOptions(menuOptions);
    const selection = await globalMainMenu.navigate();

    if (selection === -1) {
        console.log('');
        console.log(colors.green + 'üëã ' + await i18n.t('menu.main.exit') + '!' + colors.reset);
        process.exit(0);
    } else {
        await executeSelection(selection);
    }
}





/**
 * Export configuration with password encryption
 */
async function exportConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üíæ ' + await i18n.t('import_export.export.title') + colors.reset);
    console.log('');

    // Add export function description
    console.log(colors.cyan + 'üìÑ ' + i18n.tSync('import_export.export.description_title') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[2] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[3] + colors.reset);
    console.log('');

    // Verify password before export
    const verified = await verifyExportPassword(apiManager, 'export');
    if (!verified) {
        console.log('');
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return;
    }

    try {
        // Get export data
        const exportData = apiManager.exportConfigAuthenticated();

        // Prepare file path
        const exportDir = getExportDirectory();
        const filename = generateExportFilename();
        const filePath = path.join(exportDir, filename);

        // Write JSON file
        fs.writeFileSync(filePath, exportData, 'utf8');

        console.log(colors.green + '‚úì ' + i18n.tSync('import_export.export.success_title') + colors.reset);
        console.log('');
        console.log(colors.cyan + 'üìÅ ' + i18n.tSync('import_export.export.details_title') + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_file_saved', filePath) + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_export_dir', exportDir) + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_filename', filename) + colors.reset);
        console.log('');

        // Open file with default application
        console.log(colors.yellow + 'üîç ' + i18n.tSync('import_export.export.opening_file') + colors.reset);
        openFileWithDefault(filePath);

        console.log('');
        console.log(colors.cyan + 'üí° ' + i18n.tSync('import_export.export.tips_title') + colors.reset);
        console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.tips_items')[0] + colors.reset);
        console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.tips_items')[1] + colors.reset);

    } catch (error) {
        console.log(colors.red + `‚ùå Export failed: ${error.message}` + colors.reset);
    }

    console.log('');
    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Import configuration from plaintext JSON
 */
async function importConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üì• ' + await i18n.t('import_export.import.title') + colors.reset);
    console.log('');

    // Add import function description
    console.log(colors.cyan + 'üìÑ ' + i18n.tSync('ui.general.import_function_description') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[2] + colors.reset);
    console.log('');

    // Verify password identity
    const passwordVerified = await verifyExportPassword(apiManager, 'import');
    if (!passwordVerified) {
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return;
    }

    console.log('');
    console.log(colors.cyan + 'üìÅ ' + i18n.tSync('ui.general.file_input_required') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[2] + colors.reset);
    console.log('');

    const { simpleInput } = require('./lib/ui/prompts');

    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
        attempts++;

        // Get file path from user
        const filePrompt = i18n.tSync('ui.general.enter_json_file_path_attempt', attempts, maxAttempts);
        const filePath = await simpleInput(colors.green + filePrompt + colors.reset);

        if (!filePath) {
            console.log(colors.red + i18n.tSync('ui.general.file_path_empty') + colors.reset);
            if (attempts < maxAttempts) {
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_cancelled') + colors.reset);
                await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
                return;
            }
        }

        // Validate file
        console.log('');
        console.log(colors.yellow + i18n.tSync('ui.general.validating_file') + colors.reset);
        const validation = validateImportFile(filePath);

        if (!validation.valid) {
            console.log(colors.red + '‚ùå ' + i18n.tSync('ui.general.file_validation_failed', validation.error) + colors.reset);
            if (attempts < maxAttempts) {
                console.log(colors.yellow + i18n.tSync('ui.general.check_file_path_json') + colors.reset);
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_cancelled') + colors.reset);
                await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
                return;
            }
        }

        // File is valid, proceed with import
        console.log(colors.green + i18n.tSync('ui.general.file_validation_successful') + colors.reset);
        console.log('');

        try {
            // Import the validated configuration data
            const result = apiManager.importConfigAuthenticated(validation.data);

            console.log(colors.green + i18n.tSync('ui.general.import_successful') + colors.reset);
            console.log('');
            console.log(colors.cyan + i18n.tSync('ui.general.import_statistics') + colors.reset);
            const importItems = i18n.tSync('ui.general.import_stats_items');
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[0].replace('{0}', result.imported) + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[1].replace('{1}', result.skipped) + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[2] + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[3].replace('{0}', path.resolve(filePath)) + colors.reset);

            break; // Success, exit the loop

        } catch (error) {
            console.log(colors.red + `‚ùå Import failed: ${error.message}` + colors.reset);
            if (attempts < maxAttempts) {
                console.log(colors.yellow + i18n.tSync('ui.general.import_tips')[0] + colors.reset);
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_failed') + colors.reset);
            }
        }
    }

    console.log('');
    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Change password
 */
async function changePassword() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üîë ' + i18n.tSync('errors.password.change_password_title') + colors.reset);
    console.log('');

    // Use unified password change module
    const success = await changePasswordModule(apiManager);

    if (success) {
        console.log('');
    }

    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Show language settings menu
 */
async function showLanguageSettings() {
    try {
        const supportedLanguages = i18n.getSupportedLanguages();
        const currentLanguage = i18n.getCurrentLanguage();
        const currentLanguageName = i18n.getCurrentLanguageName();

        while (true) {
            console.clear();
            console.log('');
            console.log(colors.bright + colors.orange + 'üåç ' + await i18n.t('menu.language.title') + colors.reset);
            console.log('');

            // Show current language
            console.log(colors.cyan + await i18n.t('menu.language.current', currentLanguageName) + colors.reset);
            console.log('');
            console.log(colors.yellow + await i18n.t('menu.language.select_prompt') + colors.reset);
            console.log('');

            // Create menu options
            const languageOptions = [];
            const languageCodes = Object.keys(supportedLanguages);

            languageCodes.forEach(langCode => {
                const isActive = langCode === currentLanguage;
                const displayName = supportedLanguages[langCode];
                languageOptions.push(isActive ? `‚óè ${displayName}` : `  ${displayName}`);
            });

            languageOptions.push(await i18n.t('menu.language.back'));

            // Ensure global menus are initialized
            initializeGlobalMenus();

            globalApiManagementMenu.setOptions(languageOptions);
            const choice = await globalApiManagementMenu.navigate();

            if (choice === -1 || choice === languageOptions.length - 1) {
                // Back to main menu
                return showMenu();
            }

            // Check if user selected current language
            const selectedLangCode = languageCodes[choice];
            if (selectedLangCode === currentLanguage) {
                // Already current language, continue loop
                continue;
            }

            // Switch language
            console.clear();
            console.log('');
            console.log(colors.yellow + await i18n.t('status.switching_language') + colors.reset);

            try {
                await i18n.setLanguage(selectedLangCode);

                console.clear();
                const newLanguageName = i18n.getCurrentLanguageName();
                showSuccess(await i18n.t('messages.success.language_changed'), [
                    await i18n.t('menu.language.changed_success', newLanguageName)
                ]);

                await waitForKey(await i18n.t('messages.prompts.press_any_key'));

                // Continue to show updated language settings
                continue;

            } catch (error) {
                showError(await i18n.t('errors.general.operation_failed', error.message));
                await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                continue;
            }
        }

    } catch (error) {
        showError('Failed to show language settings', [error.message]);
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return showMenu();
    }
}

// End of API Management functions

/**
 * Graceful shutdown handlers
 */
process.on('SIGINT', () => {
    console.log('');
    console.log(colors.green + i18n.tSync('ui.general.goodbye') + colors.reset);
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('');
    console.log(colors.green + i18n.tSync('ui.general.goodbye') + colors.reset);
    process.exit(0);
});

// Initialize global menus and start the application
initializeGlobalMenus();
console.log(colors.dim + i18n.tSync('ui.general.launcher_version') + colors.reset);
showMenu();
