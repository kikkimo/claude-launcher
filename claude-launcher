#!/usr/bin/env node

/**
 * Claude Launcher - Refactored modular version
 * A launcher for Claude Code with third-party API support
 */

/**
 * Force complete stdin reset to prevent navigation issues
 * Note: This function should only reset state, not remove listeners
 * that might be used by other modules
 */
function forceStdinCleanup() {
    try {
        if (process.stdin.isTTY) {
            // Only reset mode, don't remove listeners that might be in use
            process.stdin.setRawMode(false);
            // NOTE: Removed removeAllListeners to prevent conflicts
            // Each module should manage its own listeners
            // Only pause if not already paused (isPaused is a method, not a property)
            if (!process.stdin.isPaused()) {
                process.stdin.pause();
            }
        }
    } catch (error) {
        // Ignore cleanup errors but log for debugging
        if (process.env.DEBUG_STDIN) {
            console.error('[DEBUG] forceStdinCleanup error:', error.message);
        }
    }
}


const ApiManager = require('./lib/api-manager');
const Menu = require('./lib/ui/menu');
const colors = require('./lib/ui/colors');
const { checkForUpdates, forceCheckForUpdates } = require('./lib/utils/version-checker');
const {
    waitForKey,
    promptForThirdPartyApi,
    confirmAction,
    showSuccess,
    showError,
    showInfo
} = require('./lib/ui/prompts');
const {
    launchClaudeDefault,
    launchClaudeSkipPermissions,
    launchClaudeWithApi
} = require('./lib/launcher');
const { getPasswordInput } = require('./lib/auth/password-input');
const { verifyExportPassword, setupNewPassword, changePassword: changePasswordModule } = require('./lib/auth/password-validator');
const { maskApiToken } = require('./lib/validators');
const { showApiSelectionTable, confirmDeletion } = require('./lib/ui/interactive-table');
const i18n = require('./lib/i18n');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { exec } = require('child_process');

// Initialize components
const apiManager = new ApiManager();

// Global menu objects to prevent screen flickering during navigation
let globalMainMenu = null;
let globalConfirmMenu = null;
let globalApiManagementMenu = null;

/**
 * Initialize global menu objects to prevent recreation and screen flickering
 */
function initializeGlobalMenus() {
    if (!globalMainMenu) {
        globalMainMenu = new Menu();
    }
    if (!globalConfirmMenu) {
        globalConfirmMenu = new Menu();
    }
    if (!globalApiManagementMenu) {
        globalApiManagementMenu = new Menu();
    }
}

/**
 * Get export directory path and create if not exists
 * @returns {string} - Export directory path
 */
function getExportDirectory() {
    const userHome = os.homedir();
    const exportDir = path.join(userHome, 'claude-launcher');

    // Create directory if it doesn't exist
    if (!fs.existsSync(exportDir)) {
        fs.mkdirSync(exportDir, { recursive: true });
    }

    return exportDir;
}

/**
 * Generate timestamp-based filename for export
 * @returns {string} - Filename with timestamp
 */
function generateExportFilename() {
    const now = new Date();
    const timestamp = now.getFullYear().toString() +
                     (now.getMonth() + 1).toString().padStart(2, '0') +
                     now.getDate().toString().padStart(2, '0') +
                     now.getHours().toString().padStart(2, '0') +
                     now.getMinutes().toString().padStart(2, '0') +
                     now.getSeconds().toString().padStart(2, '0');

    return `claude-launcher-export-${timestamp}.json`;
}

/**
 * Open file with system default application
 * @param {string} filePath - Path to the file to open
 */
function openFileWithDefault(filePath) {
    const platform = process.platform;
    let command;

    if (platform === 'win32') {
        command = `start "" "${filePath}"`;
    } else if (platform === 'darwin') {
        command = `open "${filePath}"`;
    } else {
        command = `xdg-open "${filePath}"`;
    }

    exec(command, (error) => {
        if (error) {
            console.log(colors.yellow + `Could not open file automatically: ${error.message}` + colors.reset);
        }
    });
}

/**
 * Validate import file path and JSON format
 * @param {string} filePath - Path to the JSON file
 * @returns {Object} - Validation result with success status and data/error
 */
function validateImportFile(filePath) {
    const result = {
        valid: false,
        data: null,
        error: null
    };

    try {
        // Check if file path is provided
        if (!filePath || filePath.trim() === '') {
            result.error = 'File path cannot be empty';
            return result;
        }

        // Normalize and resolve path
        const normalizedPath = path.resolve(filePath.trim());

        // Check if file exists
        if (!fs.existsSync(normalizedPath)) {
            result.error = i18n.tSync('errors.file.file_not_found', normalizedPath);
            return result;
        }

        // Check if it's a file (not directory)
        const stats = fs.statSync(normalizedPath);
        if (!stats.isFile()) {
            result.error = `Path is not a file: ${normalizedPath}`;
            return result;
        }

        // Check file extension
        if (path.extname(normalizedPath).toLowerCase() !== '.json') {
            result.error = `File must have .json extension: ${normalizedPath}`;
            return result;
        }

        // Read and parse JSON file
        const fileContent = fs.readFileSync(normalizedPath, 'utf8');

        // Validate JSON format
        let jsonData;
        try {
            jsonData = JSON.parse(fileContent);
        } catch (parseError) {
            result.error = `Invalid JSON format: ${parseError.message}`;
            return result;
        }

        // Basic structure validation for claude-launcher config
        if (!jsonData || typeof jsonData !== 'object') {
            result.error = 'JSON file must contain a valid configuration object';
            return result;
        }

        // Check for required fields (basic validation)
        if (!jsonData.hasOwnProperty('apis') || !Array.isArray(jsonData.apis)) {
            result.error = i18n.tSync('errors.file.invalid_format', 'JSON file must contain an "apis" array');
            return result;
        }

        result.valid = true;
        result.data = fileContent; // Return raw JSON string for compatibility
        return result;

    } catch (error) {
        result.error = `File validation error: ${error.message}`;
        return result;
    }
}

// Main menu options - will be populated dynamically with i18n
let menuOptions = [];

/**
 * Add new third-party API
 */
async function addNewThirdPartyApi() {
    try {
        const apiData = await promptForThirdPartyApi();

        // Check if this is the first API
        const isFirstApi = apiManager.getApis().length === 0;
        const hasExportPassword = apiManager.hasExportPassword();

        const newApi = apiManager.addApi(
            apiData.baseUrl,
            apiData.authToken,
            apiData.model,
            apiData.name,
            apiData.provider
        );

        showSuccess(await i18n.t('messages.success.api_added'), [
            `Name: ${newApi.name}`,
            `${await i18n.t('api.details.provider')}: ${newApi.provider}`,
            `${await i18n.t('api.details.url')}: ${newApi.baseUrl}`,
            `${await i18n.t('api.details.model')}: ${newApi.model}`
        ]);

        if (isFirstApi) {
            showInfo(await i18n.t('messages.info.first_time_usage'));
        }

    } catch (error) {
        // Force cleanup stdin state to prevent navigation issues
        forceStdinCleanup();

        // Check if user cancelled the operation
        const cancelledMessage = await i18n.t('errors.general.cancelled_by_user');
        if (error.message === cancelledMessage) {
            // User cancelled - show neutral message instead of error
            console.log(colors.yellow + await i18n.t('messages.info.operation_cancelled') + colors.reset);
        } else {
            // Actual error occurred
            showError(await i18n.t('errors.api.failed_add', error.message));
        }
    }

    await waitForKey(await i18n.t('messages.prompts.press_any_key'));
}

/**
 * Remove third-party API
 */
async function removeThirdPartyApi() {
    try {
        // Get API list
        const apis = apiManager.getApis();
        const activeApi = apiManager.getActiveApi();
        const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

        // Show API selection table (handles no APIs case internally)
        const selectedApi = await showApiSelectionTable(
            apis,
            i18n.tSync('ui.general.select_api_remove'),
            'remove',
            activeIndex
        );

        if (!selectedApi) {
            return showMenu();
        }

        // Show confirmation dialog
        const confirmed = await confirmDeletion(selectedApi);

        if (confirmed) {
            try {
                // Find the index of the selected API in the current list
                const selectedIndex = apis.findIndex(api => api.id === selectedApi.id);
                apiManager.removeApi(selectedIndex);

                console.clear();
                showSuccess(await i18n.t('messages.success.api_removed'), [
                    `${await i18n.t('api.actions.removed_info', selectedApi.name)}`,
                    `${await i18n.t('api.details.provider')}: ${selectedApi.provider}`
                ]);

                // Show success message and return to main menu
                const remainingApis = apiManager.getApis();
                if (remainingApis.length === 0) {
                    showInfo(await i18n.t('messages.info.all_apis_removed'));
                }
                await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                return showMenu();

            } catch (removeError) {
                showError(await i18n.t('errors.api.failed_remove', removeError.message));
                await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                return showMenu();
            }
        } else {
            showInfo(await i18n.t('messages.info.removal_cancelled'));
            await waitForKey(await i18n.t('messages.prompts.press_any_key'));
            return showMenu();
        }

    } catch (error) {
        forceStdinCleanup();
        showError('Failed to remove API', [error.message]);
        await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
    }
}

/**
 * Switch active third-party API
 */
async function switchThirdPartyApi() {
    try {
        const apis = apiManager.getApis();
        const activeApi = apiManager.getActiveApi();
        const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

        // Áé∞Âú®Ë°®Ê†ºÂáΩÊï∞ÂÜÖÈÉ®Â§ÑÁêÜÊï¥‰∏™ÂàáÊç¢ÊµÅÁ®ã
        const selectedApi = await showApiSelectionTable(
            apis,
            i18n.tSync('api.actions.select_to_switch'),
            'switch',
            activeIndex,
            apiManager  // ‰º†ÈÄí apiManager ËÆ©Ë°®Ê†ºÂáΩÊï∞Â§ÑÁêÜÂàáÊç¢ÈÄªËæë
        );

        // Ë°®Ê†ºÂáΩÊï∞Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÊâÄÊúâÊòæÁ§∫ÂíåÂàáÊç¢ÈÄªËæëÔºåÁõ¥Êé•ËøîÂõû‰∏ªËèúÂçï
        return showMenu();

    } catch (error) {
        forceStdinCleanup();
        showError(await i18n.t('errors.api.failed_switch', error.message));
        await waitForKey(await i18n.t('messages.prompts.press_any_key'));
        return showMenu();
    }
}

/**
 * View API statistics
 */
/**
 * Format timestamp to relative time
 * @param {string|null} timestamp - ISO timestamp or null
 * @returns {string} Relative time string
 */
function formatRelativeTime(timestamp) {
    if (!timestamp) return i18n.tSync('statistics.time_never');

    const now = Date.now();
    const diff = now - new Date(timestamp).getTime();
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return i18n.tSync('statistics.time_just_now');
    if (minutes < 60) return i18n.tSync('statistics.time_minutes_ago', minutes);
    if (hours < 24) return i18n.tSync('statistics.time_hours_ago', hours);
    return i18n.tSync('statistics.time_days_ago', days);
}

async function viewStatistics() {
    const { padStringToWidth } = require('./lib/utils/string-width');

    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üìä ' + await i18n.t('statistics.title') + colors.reset);
    console.log('');

    const stats = apiManager.getEnhancedStatistics();

    // Summary section
    console.log(colors.cyan + '  ' + i18n.tSync('ui.general.summary') + ':' + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.total_apis', stats.totalApis)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.active_api', stats.activeApiName)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.most_used', stats.mostUsedApi)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.total_usage', stats.totalUsage)}` + colors.reset);
    console.log(colors.gray + `    ${await i18n.t('statistics.success_rate', stats.successRate)}` + colors.reset);
    console.log('');

    if (stats.apiStats.length > 0) {
        console.log(colors.cyan + '  ' + i18n.tSync('ui.general.configured_apis') + ':' + colors.reset);
        console.log('');

        // Table header
        console.log(colors.dim + '    ' +
            padStringToWidth(await i18n.t('statistics.header_name'), 20) +
            padStringToWidth(await i18n.t('statistics.header_usage'), 10) +
            padStringToWidth(await i18n.t('statistics.header_success'), 10) +
            await i18n.t('statistics.header_last_used') +
            colors.reset);
        console.log(colors.dim + '    ' + '‚îÄ'.repeat(60) + colors.reset);

        for (const api of stats.apiStats) {
            const lastUsedText = formatRelativeTime(api.lastUsed);
            console.log(colors.gray + '    ' +
                padStringToWidth(api.name, 20) +
                padStringToWidth(String(api.usageCount), 10) +
                padStringToWidth(api.successRate, 10) +
                lastUsedText +
                colors.reset);
        }
    }

    console.log('');

    // Use menu for actions instead of special key handling
    const menuOptions = [
        await i18n.t('statistics.menu_reset'),
        await i18n.t('statistics.menu_back')
    ];

    initializeGlobalMenus();
    globalApiManagementMenu.setOptions(menuOptions);
    const choice = await globalApiManagementMenu.navigate();

    if (choice === 0) { // Reset Statistics
        const { simpleInput } = require('./lib/ui/prompts');
        const confirm = await simpleInput(colors.yellow + '  ' + await i18n.t('statistics.reset_confirm') + ' ' + colors.reset);
        if (confirm.toLowerCase() === 'y') {
            apiManager.resetStatistics();
            console.log(colors.green + '  ‚úì ' + await i18n.t('statistics.reset_success') + colors.reset);
            await waitForKey(await i18n.t('messages.prompts.press_any_key'));
        }
        return viewStatistics();
    }
    // choice === 1 or -1: Back - just return
}


/**
 * Handle first time password setup
 */
async function handleFirstTimePasswordSetup() {
    while (true) {
        // Clear screen and show header
        console.clear();
        console.log('');
        console.log(colors.bright + colors.yellow + 'üîê ' + i18n.tSync('password.setup.first_time_title') + colors.reset);
        console.log('');

        // Show information
        console.log(colors.cyan + i18n.tSync('password.setup.why_needed') + colors.reset);
        const whyNeededItems = i18n.tSync('password.setup.why_needed_items');
        if (Array.isArray(whyNeededItems)) {
            whyNeededItems.forEach(item => {
                console.log(colors.gray + '‚Ä¢ ' + item + colors.reset);
            });
        }
        console.log('');
        console.log(colors.cyan + 'üîí ' + i18n.tSync('password.setup.new_security_title') + colors.reset);
        const securityItems = i18n.tSync('password.setup.security_items');
        if (Array.isArray(securityItems)) {
            securityItems.forEach(item => {
                console.log(colors.gray + '‚Ä¢ ' + item + colors.reset);
            });
        }
        console.log('');
        console.log(colors.yellow + i18n.tSync('password.setup.options_title') + colors.reset);
        console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('password.setup.option_set') + colors.reset);
        console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('password.setup.option_skip') + colors.reset);
        console.log('');
        console.log(colors.red + i18n.tSync('password.setup.warning_skip') + colors.reset);
        console.log('');

        console.log(colors.gray + 'Êåâ‰ªªÊÑèÈîÆÁªßÁª≠...' + colors.reset);

        // Wait for user to read the information
        await new Promise((resolve) => {
            if (process.stdin.isTTY) {
                process.stdin.setRawMode(true);
                process.stdin.resume();
                process.stdin.once('data', () => {
                    try {
                        process.stdin.setRawMode(false);
                        process.stdin.pause();
                    } catch (error) {
                        // Ignore cleanup errors
                    }
                    resolve();
                });
            } else {
                resolve();
            }
        });

        // Now show the menu for selection
        const menuOptions = [
            i18n.tSync('password.setup.menu_set_password'),
            i18n.tSync('password.setup.menu_skip_setup'),
            i18n.tSync('menu.api_management.back')
        ];

        // Ensure global menus are initialized
        initializeGlobalMenus();
        globalConfirmMenu.setOptions(menuOptions);

        const choice = await globalConfirmMenu.navigate();

        switch (choice) {
            case 0: // Set password
                const passwordResult = await promptForPasswordSetup();
                if (passwordResult) {
                    return true; // Password set successfully
                }
                // If password setup failed, continue loop to show menu again
                break;

            case 1: // Skip setup
                const skipResult = await confirmSkipPassword();
                if (skipResult === true) {
                    return true; // Skip confirmed
                } else if (skipResult === 'reconsider') {
                    continue; // Return to main setup menu
                }
                // If skip was canceled, continue loop
                break;

            case 2: // Back to main menu
            case -1: // ESC pressed
            default:
                return false; // Exit setup
        }
    }
}

/**
 * Prompt user to set password
 */
async function promptForPasswordSetup() {
    const result = await setupNewPassword(apiManager, true);
    if (result) {
        await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
    }
    return result;
}

/**
 * Confirm skip password setup
 */
async function confirmSkipPassword() {
    console.log('');
    console.log(colors.bright + colors.red + '‚ö†Ô∏è  ' + i18n.tSync('errors.password.confirm_skip_title') + colors.reset);
    console.log('');
    console.log(colors.gray + i18n.tSync('ui.general.after_skipping_password_setup') + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[0] + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[1] + colors.reset);
    console.log(colors.gray + '‚Ä¢ ' + i18n.tSync('ui.general.password_skip_consequences')[2] + colors.reset);
    console.log('');

    // Ensure global menus are initialized
    initializeGlobalMenus();

    globalConfirmMenu.setOptions([
        i18n.tSync('ui.general.confirm_skip_option'),
        i18n.tSync('ui.general.reconsider_option')
    ]);

    const choice = await globalConfirmMenu.navigate();

    if (choice === 0) {
        try {
            apiManager.skipPasswordSetup();
            console.log(colors.yellow + i18n.tSync('errors.password.setup_skipped') + colors.reset);
            await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
            return true;
        } catch (error) {
            forceStdinCleanup();
            console.log(colors.red + `Operation failed: ${error.message}` + colors.reset);
            await waitForKey(i18n.tSync('messages.prompts.press_any_key'));
            return false;
        }
    }

    return 'reconsider'; // Return to password setup main menu
}

/**
 * Show API Management Menu
 */
async function showApiManagementMenu() {
    // Force cleanup stdin state before showing API management menu
    forceStdinCleanup();

    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üìã ' + await i18n.t('menu.api_management.title') + colors.reset);
    console.log('');

    // Check if this is first time usage and prompt for password setup
    if (apiManager.isFirstTimeUsage()) {
        const passwordChoice = await handleFirstTimePasswordSetup();
        if (!passwordChoice) {
            // User chose to skip or canceled, return to main menu
            return showMenu();
        }
    }

    // Build menu options based on password setup status
    const menuOptions = [
        await i18n.t('menu.api_management.add_new'),      // 0
        await i18n.t('menu.api_management.remove'),       // 1
        await i18n.t('menu.api_management.switch'),       // 2
        await i18n.t('menu.api_management.statistics')    // 3
    ];

    // Add import/export options only if password is set
    if (apiManager.canUseImportExport()) {
        menuOptions.push(await i18n.t('menu.api_management.export'));          // 4
        menuOptions.push(await i18n.t('menu.api_management.import'));          // 5
        menuOptions.push(await i18n.t('menu.api_management.change_password')); // 6
    }

    // Add model upgrade settings (always available)
    menuOptions.push(await i18n.t('model_upgrade.settings_title'));  // 4 or 7 (depending on import/export)

    menuOptions.push(await i18n.t('menu.api_management.back'));      // 5 or 8

    // Ensure global menus are initialized
    initializeGlobalMenus();

    globalApiManagementMenu.setOptions(menuOptions);

    const choice = await globalApiManagementMenu.navigate();

    // Handle menu choices based on current menu options
    if (choice === 0) { // Add New API
        await addNewThirdPartyApi();
        return showMenu();
    } else if (choice === 1) { // Remove API
        await removeThirdPartyApi();
        return showMenu();
    } else if (choice === 2) { // Switch Active API
        await switchThirdPartyApi();
        return showMenu();
    } else if (choice === 3) { // View API Statistics
        await viewStatistics();
        return showMenu();
    } else if (apiManager.canUseImportExport()) {
        // With import/export enabled: indices 4-8
        if (choice === 4) { // Export Configuration
            await exportConfiguration();
            return showMenu();
        } else if (choice === 5) { // Import Configuration
            await importConfiguration();
            return showMenu();
        } else if (choice === 6) { // Change Password
            await changePassword();
            return showMenu();
        } else if (choice === 7) { // Model Upgrade Settings (NEW)
            return await showModelUpgradeSettings();
        } else if (choice === 8) { // Back to Main Menu
            return showMenu();
        }
    } else {
        // Without import/export: indices 4-5
        if (choice === 4) { // Model Upgrade Settings (NEW)
            return await showModelUpgradeSettings();
        } else if (choice === 5) { // Back to Main Menu
            return showMenu();
        }
    }

    // Default fallback to main menu
    return showMenu();
}

/**
 * Show model upgrade settings menu
 */
async function showModelUpgradeSettings() {
    const versionChecker = require('./lib/utils/version-checker');
    const upgradeChecker = require('./lib/utils/model-upgrade-checker');

    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + '‚öôÔ∏è  ' + await i18n.t('model_upgrade.settings_title') + colors.reset);
    console.log('');

    const config = await versionChecker.loadConfig();
    const isAutoOn = config.autoModelUpgrade === true;

    console.log(colors.cyan + '  ' + await i18n.t('model_upgrade.current_config') + ':' + colors.reset);
    console.log(colors.gray + '    ' + await i18n.t('model_upgrade.auto_upgrade_label') + ': ' +
        (isAutoOn
            ? colors.green + await i18n.t('model_upgrade.auto_upgrade_on')
            : colors.dim + await i18n.t('model_upgrade.auto_upgrade_off')
        ) + colors.reset);
    console.log('');

    const menuOptions = [
        await i18n.t('model_upgrade.menu_toggle_auto',
            isAutoOn ? await i18n.t('model_upgrade.auto_upgrade_on') : await i18n.t('model_upgrade.auto_upgrade_off'),
            isAutoOn ? await i18n.t('model_upgrade.auto_upgrade_off') : await i18n.t('model_upgrade.auto_upgrade_on')
        ),
        await i18n.t('model_upgrade.menu_manual_upgrade'),
        await i18n.t('model_upgrade.menu_back')
    ];

    initializeGlobalMenus();
    globalApiManagementMenu.setOptions(menuOptions);
    const choice = await globalApiManagementMenu.navigate();

    switch (choice) {
        case 0: // Toggle auto upgrade
            await versionChecker.setAutoModelUpgrade(!isAutoOn);
            console.log('');
            console.log(colors.green + '‚úì ' + await i18n.t('model_upgrade.auto_upgrade_label') + ': ' +
                (!isAutoOn
                    ? await i18n.t('model_upgrade.auto_upgrade_on')
                    : await i18n.t('model_upgrade.auto_upgrade_off')
                ) + colors.reset);
            await waitForKey(await i18n.t('messages.prompts.press_any_key'));
            return showModelUpgradeSettings();

        case 1: // Manual upgrade
            await performManualUpgrade();
            return showModelUpgradeSettings();

        case 2: // Back
        case -1:
        default:
            return showApiManagementMenu();
    }
}

/**
 * Perform manual upgrade for all APIs with interactive confirmation
 */
async function performManualUpgrade() {
    const { getLatestModel, getProvider } = require('./lib/presets/providers');
    const { simpleInput } = require('./lib/ui/prompts');

    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üîÑ ' + await i18n.t('model_upgrade.manual_title') + colors.reset);
    console.log('');

    const apis = apiManager.getApis();

    if (apis.length === 0) {
        console.log(colors.yellow + '  ' + await i18n.t('messages.info.no_apis') + colors.reset);
        await waitForKey(await i18n.t('messages.prompts.press_any_key'));
        return;
    }

    console.log(colors.gray + '  ' + await i18n.t('model_upgrade.manual_checking', apis.length) + colors.reset);
    console.log('');

    let upgradedCount = 0;
    let skippedUpToDate = 0;
    let skippedNoInfo = 0;
    let skippedByUser = 0;

    for (let i = 0; i < apis.length; i++) {
        const api = apis[i];
        const latestModel = getLatestModel(api.model, api.provider);

        console.log(colors.cyan + '  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ' + colors.reset);
        console.log(colors.bright + `  ${i + 1}/${apis.length}  ${api.name}` + colors.reset);
        console.log(colors.gray + '       ' + await i18n.t('model_upgrade.manual_api_current', api.model) + colors.reset);

        if (latestModel) {
            console.log(colors.green + '       ' + await i18n.t('model_upgrade.manual_api_latest', latestModel) + colors.reset);
            console.log('');

            // Ask for confirmation
            const answer = await simpleInput(colors.yellow + '       ' + await i18n.t('model_upgrade.manual_confirm') + ' ' + colors.reset);

            if (answer.toLowerCase() !== 'n') {
                apiManager.updateApiModel(api.id, latestModel);
                console.log(colors.green + '       ‚úì ' + await i18n.t('model_upgrade.manual_upgraded', api.model, latestModel) + colors.reset);
                upgradedCount++;
            } else {
                console.log(colors.dim + '       ' + await i18n.t('model_upgrade.manual_skipped') + colors.reset);
                skippedByUser++;
            }
        } else {
            // No upgrade info available - check if model exists in provider
            const provider = getProvider(api.provider);
            if (provider && provider.models && provider.models.includes(api.model)) {
                // Model exists in provider, likely already latest or no alias defined
                console.log(colors.dim + '       ' + await i18n.t('model_upgrade.manual_api_uptodate') + colors.reset);
                skippedUpToDate++;
            } else {
                console.log(colors.dim + '       ' + await i18n.t('model_upgrade.manual_api_no_info') + colors.reset);
                skippedNoInfo++;
            }
        }

        console.log('');
    }

    console.log(colors.cyan + '  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ' + colors.reset);
    console.log('');
    console.log(colors.green + '  ' + await i18n.t('model_upgrade.manual_complete') + colors.reset);
    console.log(colors.gray + '    ' + await i18n.t('model_upgrade.manual_stats_upgraded', upgradedCount) + colors.reset);
    console.log(colors.gray + '    ' + await i18n.t('model_upgrade.manual_stats_skipped',
        skippedUpToDate + skippedNoInfo + skippedByUser,
        skippedUpToDate,
        skippedNoInfo) + colors.reset);
    console.log('');

    await waitForKey(await i18n.t('messages.prompts.press_any_key'));
}

/**
 * Handle third-party API launch
 */
async function handleThirdPartyApiLaunch(skipPermissions = false) {
    try {
        const activeApi = apiManager.getActiveApi();

        if (!activeApi) {
            console.clear();
            showInfo(i18n.tSync('launch.no_active_api'), [
                i18n.tSync('launch.no_active_api_desc'),
                i18n.tSync('launch.add_configure_first')
            ]);

            await waitForKey(i18n.tSync('launch.press_key_return'));
            return showMenu();
        }

        // Record successful launch BEFORE launching (since process exits after)
        apiManager.recordSuccessfulLaunch();

        launchClaudeWithApi(activeApi, skipPermissions);

    } catch (error) {
        // Record failed launch
        apiManager.recordFailedLaunch(error.message);

        showError('Failed to launch with third-party API', [error.message]);

        setTimeout(() => {
            showMenu();
        }, 2000);
    }
}

/**
 * Execute selected menu item
 */
async function executeSelection(selectedIndex) {
    switch (selectedIndex) {
        case 0: // Launch Claude Code
            launchClaudeDefault();
            break;

        case 1: // Launch Claude Code (Skip Permissions)
            launchClaudeSkipPermissions();
            break;

        case 2: // Launch Claude Code with 3rd-party API
            await handleThirdPartyApiLaunch(false);
            break;

        case 3: // Launch Claude Code with 3rd-party API (Skip Permissions)
            await handleThirdPartyApiLaunch(true);
            break;

        case 4: // 3rd-party API Management
            return await showApiManagementMenu();

        case 5: // Language Settings
            return await showLanguageSettings();

        case 6: // Version Update Check
            return await showVersionUpdateCheck();

        case 7: // Exit
            console.log('');
            console.log(colors.green + 'üëã ' + await i18n.t('menu.main.exit') + '!' + colors.reset);
            process.exit(0);
            break;

        default:
            showMenu();
            break;
    }
}

/**
 * Show main menu
 */
async function showMenu() {
    // Force cleanup stdin state before showing main menu
    forceStdinCleanup();

    // Ensure global menus are initialized
    initializeGlobalMenus();

    // ========================================
    // Version check configuration (hardcoded, modify as needed)
    // ========================================
    const ALWAYS_SHOW_VERSION = false;           // Version display toggle: true=always show, false=only show updates
    const VERSION_CHECK_INTERVAL_HOURS = 12;    // Version check interval (hours): modify this to adjust check frequency

    // Check for updates and prepare version info string
    let versionInfo = null;
    try {
        const updateInfo = await checkForUpdates(false, VERSION_CHECK_INTERVAL_HOURS);

        // Use hardcoded switch instead of config file settings
        const shouldShowVersion = ALWAYS_SHOW_VERSION || updateInfo.available;

        if (shouldShowVersion) {
            if (updateInfo.available) {
                // Display update notification (Claude Code style)
                versionInfo = colors.yellow + '  ‚ö†Ô∏è  ' + i18n.tSync('version.update_available', updateInfo.latestVersion, updateInfo.currentVersion) + colors.reset + '\n' +
                             colors.yellow + '     ' + i18n.tSync('version.install_command') + colors.reset;
            } else if (ALWAYS_SHOW_VERSION) {
                // Display current version info (always show mode)
                versionInfo = colors.cyan + '  ‚ÑπÔ∏è  ' + i18n.tSync('version.current_version_info', updateInfo.currentVersion, updateInfo.latestVersion) + colors.reset + '\n' +
                             colors.yellow + '     ' + i18n.tSync('version.install_command') + colors.reset;
            }
        }
    } catch (error) {
        // Silently ignore update check errors
    }

    // ========================================
    // Model upgrade check (new feature)
    // ========================================
    let modelUpgradeInfo = null;
    try {
        const upgradeChecker = require('./lib/utils/model-upgrade-checker');
        const result = await upgradeChecker.checkForModelUpgrades(apiManager);

        if (result.needsCheck && result.upgrades.length > 0) {
            // Check if auto upgrade is enabled
            const autoUpgrade = await upgradeChecker.isAutoUpgradeEnabled();

            if (autoUpgrade) {
                // Perform auto upgrade
                const upgraded = upgradeChecker.performAutoUpgrade(apiManager, result.upgrades);
                if (upgraded.length > 0) {
                    modelUpgradeInfo = colors.green + '  ‚úì ' +
                        i18n.tSync('model_upgrade.auto_upgraded', upgraded[0].from, upgraded[0].to) + colors.reset;
                    if (upgraded.length > 1) {
                        modelUpgradeInfo += '\n' + colors.green + '    ' +
                            `(+${upgraded.length - 1} more)` + colors.reset;
                    }
                }
            } else {
                // Show notification
                const first = result.upgrades[0];
                modelUpgradeInfo = colors.yellow + '  ‚ö†Ô∏è  ' +
                    i18n.tSync('model_upgrade.notification', first.currentModel, first.latestModel) +
                    colors.reset + '\n' +
                    colors.yellow + '      ' +
                    i18n.tSync('model_upgrade.notification_api', first.apiName) +
                    colors.reset + '\n' +
                    colors.gray + '      ' +
                    i18n.tSync('model_upgrade.notification_hint') +
                    colors.reset;
            }
        }
    } catch (error) {
        // Silently ignore model upgrade check errors
    }

    // Combine version info and model upgrade info
    let displayInfo = '';
    if (versionInfo) {
        displayInfo += versionInfo;
    }
    if (modelUpgradeInfo) {
        if (displayInfo) {
            displayInfo += '\n';
        }
        displayInfo += modelUpgradeInfo;
    }

    // Populate menu options dynamically with i18n translations
    menuOptions = [
        await i18n.t('menu.main.launch_default'),
        await i18n.t('menu.main.launch_skip'),
        await i18n.t('menu.main.launch_api'),
        await i18n.t('menu.main.launch_api_skip'),
        await i18n.t('menu.main.api_management'),
        await i18n.t('menu.main.language_settings'),
        await i18n.t('menu.main.version_check'),
        await i18n.t('menu.main.exit')
    ];

    globalMainMenu.setOptions(menuOptions);
    const selection = await globalMainMenu.navigate(false, displayInfo || null); // Pass combined info to display between banner and nav

    if (selection === -1) {
        console.log('');
        console.log(colors.green + 'üëã ' + await i18n.t('menu.main.exit') + '!' + colors.reset);
        process.exit(0);
    } else {
        await executeSelection(selection);
    }
}





/**
 * Export configuration with password encryption
 */
async function exportConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üíæ ' + await i18n.t('import_export.export.title') + colors.reset);
    console.log('');

    // Add export function description
    console.log(colors.cyan + 'üìÑ ' + i18n.tSync('import_export.export.description_title') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[2] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[3] + colors.reset);
    console.log('');

    // Verify password before export
    const verified = await verifyExportPassword(apiManager, 'export');
    if (!verified) {
        console.log('');
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return;
    }

    try {
        // Get export data
        const exportData = apiManager.exportConfigAuthenticated();

        // Prepare file path
        const exportDir = getExportDirectory();
        const filename = generateExportFilename();
        const filePath = path.join(exportDir, filename);

        // Write JSON file
        fs.writeFileSync(filePath, exportData, 'utf8');

        console.log(colors.green + '‚úì ' + i18n.tSync('import_export.export.success_title') + colors.reset);
        console.log('');
        console.log(colors.cyan + 'üìÅ ' + i18n.tSync('import_export.export.details_title') + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_file_saved', filePath) + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_export_dir', exportDir) + colors.reset);
        console.log(colors.gray + `  ‚Ä¢ ` + i18n.tSync('import_export.export.details_filename', filename) + colors.reset);
        console.log('');

        // Open file with default application
        console.log(colors.yellow + 'üîç ' + i18n.tSync('import_export.export.opening_file') + colors.reset);
        openFileWithDefault(filePath);

        console.log('');
        console.log(colors.cyan + 'üí° ' + i18n.tSync('import_export.export.tips_title') + colors.reset);
        console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.tips_items')[0] + colors.reset);
        console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.tips_items')[1] + colors.reset);

    } catch (error) {
        forceStdinCleanup();
        console.log(colors.red + `‚ùå Export failed: ${error.message}` + colors.reset);
    }

    console.log('');
    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Import configuration from plaintext JSON
 */
async function importConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üì• ' + await i18n.t('import_export.import.title') + colors.reset);
    console.log('');

    // Add import function description
    console.log(colors.cyan + 'üìÑ ' + i18n.tSync('ui.general.import_function_description') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('import_export.export.description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.import_description_items')[2] + colors.reset);
    console.log('');

    // Verify password identity
    const passwordVerified = await verifyExportPassword(apiManager, 'import');
    if (!passwordVerified) {
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return;
    }

    console.log('');
    console.log(colors.cyan + 'üìÅ ' + i18n.tSync('ui.general.file_input_required') + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[0] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[1] + colors.reset);
    console.log(colors.gray + '  ‚Ä¢ ' + i18n.tSync('ui.general.file_input_items')[2] + colors.reset);
    console.log('');

    const { simpleInput } = require('./lib/ui/prompts');

    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
        attempts++;

        // Get file path from user
        const filePrompt = i18n.tSync('ui.general.enter_json_file_path_attempt', attempts, maxAttempts);
        const filePath = await simpleInput(colors.green + filePrompt + colors.reset);

        if (!filePath) {
            console.log(colors.red + i18n.tSync('ui.general.file_path_empty') + colors.reset);
            if (attempts < maxAttempts) {
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_cancelled') + colors.reset);
                await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
                return;
            }
        }

        // Validate file
        console.log('');
        console.log(colors.yellow + i18n.tSync('ui.general.validating_file') + colors.reset);
        const validation = validateImportFile(filePath);

        if (!validation.valid) {
            console.log(colors.red + '‚ùå ' + i18n.tSync('ui.general.file_validation_failed', validation.error) + colors.reset);
            if (attempts < maxAttempts) {
                console.log(colors.yellow + i18n.tSync('ui.general.check_file_path_json') + colors.reset);
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_cancelled') + colors.reset);
                await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
                return;
            }
        }

        // File is valid, proceed with import
        console.log(colors.green + i18n.tSync('ui.general.file_validation_successful') + colors.reset);
        console.log('');

        try {
            // Import the validated configuration data
            const result = apiManager.importConfigAuthenticated(validation.data);

            console.log(colors.green + i18n.tSync('ui.general.import_successful') + colors.reset);
            console.log('');
            console.log(colors.cyan + i18n.tSync('ui.general.import_statistics') + colors.reset);
            const importItems = i18n.tSync('ui.general.import_stats_items');
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[0].replace('{0}', result.imported) + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[1].replace('{1}', result.skipped) + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[2] + colors.reset);
            console.log(colors.gray + `  ‚Ä¢ ` + importItems[3].replace('{0}', path.resolve(filePath)) + colors.reset);

            break; // Success, exit the loop

        } catch (error) {
            forceStdinCleanup();
            console.log(colors.red + `‚ùå Import failed: ${error.message}` + colors.reset);
            if (attempts < maxAttempts) {
                console.log(colors.yellow + i18n.tSync('ui.general.import_tips')[0] + colors.reset);
                console.log('');
                continue;
            } else {
                console.log(colors.red + i18n.tSync('ui.general.max_attempts_import_failed') + colors.reset);
            }
        }
    }

    console.log('');
    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Change password
 */
async function changePassword() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'üîë ' + i18n.tSync('errors.password.change_password_title') + colors.reset);
    console.log('');

    // Use unified password change module
    const success = await changePasswordModule(apiManager);

    if (success) {
        console.log('');
    }

    await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
}

/**
 * Show language settings menu
 */
async function showLanguageSettings() {
    try {
        const supportedLanguages = i18n.getSupportedLanguages();
        const currentLanguage = i18n.getCurrentLanguage();
        const currentLanguageName = i18n.getCurrentLanguageName();

        console.clear();
        console.log('');
        console.log(colors.bright + colors.orange + 'üåç ' + await i18n.t('menu.language.title') + colors.reset);
        console.log('');

        // Show current language
        console.log(colors.cyan + await i18n.t('menu.language.current', currentLanguageName) + colors.reset);
        console.log('');
        console.log(colors.yellow + await i18n.t('menu.language.select_prompt') + colors.reset);
        console.log('');

        // Create menu options
        const languageOptions = [];
        const languageCodes = Object.keys(supportedLanguages);

        languageCodes.forEach(langCode => {
            const isActive = langCode === currentLanguage;
            const displayName = supportedLanguages[langCode];
            languageOptions.push(isActive ? `‚óè ${displayName}` : `  ${displayName}`);
        });

        languageOptions.push(await i18n.t('menu.language.back'));

        // Ensure global menus are initialized
        initializeGlobalMenus();

        globalApiManagementMenu.setOptions(languageOptions);
        const choice = await globalApiManagementMenu.navigate();

        if (choice === -1 || choice === languageOptions.length - 1) {
            // Back to main menu
            return showMenu();
        }

        // Check if user selected current language
        const selectedLangCode = languageCodes[choice];
        if (selectedLangCode === currentLanguage) {
            // Already current language, return to main menu
            return showMenu();
        }

        // Switch language
        console.clear();
            console.log('');
            console.log(colors.yellow + await i18n.t('status.switching_language') + colors.reset);

            try {
                await i18n.setLanguage(selectedLangCode);

                console.clear();
                const newLanguageName = i18n.getCurrentLanguageName();
                showSuccess(await i18n.t('messages.success.language_changed'), [
                    await i18n.t('menu.language.changed_success', newLanguageName)
                ]);

                await waitForKey(await i18n.t('messages.prompts.press_any_key'));

                // Return to main menu after successful language change
                return showMenu();

            } catch (error) {
                showError(await i18n.t('errors.general.operation_failed', error.message));
                await waitForKey(await i18n.t('messages.prompts.press_any_key'));
                return showMenu();
            }

    } catch (error) {
        showError('Failed to show language settings', [error.message]);
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return showMenu();
    }
}

/**
 * Show version update check screen
 */
async function showVersionUpdateCheck() {
    try {
        console.clear();
        console.log('');
        console.log(colors.bright + colors.orange + 'üîÑ ' + await i18n.t('version_check.title') + colors.reset);
        console.log('');

        console.log(colors.cyan + await i18n.t('version_check.checking') + colors.reset);
        console.log(colors.gray + await i18n.t('version_check.please_wait') + colors.reset);
        console.log('');

        // Show progress indicator
        const progressInterval = setInterval(() => {
            process.stdout.write('.');
        }, 500);

        try {
            // Force check with 15 second timeout
            const result = await forceCheckForUpdates(15000);

            // Stop progress indicator
            clearInterval(progressInterval);
            console.log('\n');

            if (result.error) {
                // Handle errors (timeout, network, etc.)
                console.log(colors.red + '‚ùå ' + await i18n.t('version_check.error') + colors.reset);
                console.log(colors.red + '   ' + result.error + colors.reset);
                console.log('');
                console.log(colors.gray + await i18n.t('version_check.error_tips') + colors.reset);
            } else if (result.available) {
                // Update available
                console.log(colors.yellow + 'üéâ ' + await i18n.t('version_check.update_available') + colors.reset);
                console.log('');
                console.log(colors.cyan + '   ' + await i18n.t('version_check.current_version', result.currentVersion) + colors.reset);
                console.log(colors.green + '   ' + await i18n.t('version_check.latest_version', result.latestVersion) + colors.reset);
                console.log('');
                console.log(colors.yellow + 'üí° ' + await i18n.t('version_check.update_command') + colors.reset);
                console.log(colors.yellow + '   npm update -g @kikkimo/claude-launcher' + colors.reset);
            } else {
                // Already up to date
                console.log(colors.green + '‚úÖ ' + await i18n.t('version_check.up_to_date') + colors.reset);
                console.log('');
                console.log(colors.cyan + '   ' + await i18n.t('version_check.current_version', result.currentVersion) + colors.reset);
                console.log(colors.cyan + '   ' + await i18n.t('version_check.latest_version', result.latestVersion) + colors.reset);
            }

        } catch (error) {
            // Stop progress indicator
            clearInterval(progressInterval);
            console.log('\n');

            console.log(colors.red + '‚ùå ' + await i18n.t('version_check.unexpected_error') + colors.reset);
            console.log(colors.red + '   ' + error.message + colors.reset);
        }

        console.log('');
        await waitForKey(await i18n.t('messages.prompts.press_any_key'));
        return showMenu();

    } catch (error) {
        console.log(colors.red + '‚ùå Failed to check version: ' + error.message + colors.reset);
        await waitForKey(i18n.tSync('messages.prompts.press_any_key_menu'));
        return showMenu();
    }
}

// End of API Management functions

/**
 * Graceful shutdown handlers
 */
process.on('SIGTERM', () => {
    console.log('');
    console.log(colors.green + i18n.tSync('ui.general.goodbye') + colors.reset);
    process.exit(0);
});

// Global SIGINT handler (Ctrl+C) - fallback for non-raw mode Ctrl+C
// In raw mode, Ctrl+C is handled by StdinManager directly
// This handler catches Ctrl+C in line mode (e.g., during readline input)
const stdinManager = require('./lib/utils/stdin-manager');

// Flag to prevent re-entrance of SIGINT handler
let exiting = false;

process.on('SIGINT', () => {
    // During Claude run, ignore in launcher so child handles it
    // Check this BEFORE setting exiting flag to avoid breaking reentrancy protection
    if (stdinManager.isSuspended && stdinManager.isSuspended()) {
        return;
    }

    // Prevent re-entrance - ensure cleanup runs only once
    if (exiting) {
        return;
    }
    exiting = true;

    // Try to reset stdin state before handling
    try {
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(false);
            process.stdin.pause();
        }
    } catch (_) {
        // Ignore errors during emergency cleanup
    }

    // Use unified Ctrl+C handler from StdinManager (synchronous)
    try {
        stdinManager.handleCtrlC();
    } catch (_) {
        // Ignore errors during Ctrl+C handling
    }

    // Exit with standard SIGINT exit code (128 + 2 = 130)
    // Note: If handleCtrlC() calls process.exit(0) for second Ctrl+C,
    // this line won't be reached, which is expected behavior
    process.exit(130);
});

// Initialize global menus and start the application
initializeGlobalMenus();

// Start the application
showMenu();
