#!/usr/bin/env node

/**
 * Claude Launcher - Refactored modular version
 * A launcher for Claude Code with third-party API support
 */

const ApiManager = require('./lib/api-manager');
const Menu = require('./lib/ui/menu');
const colors = require('./lib/ui/colors');
const {
    waitForKey,
    promptForThirdPartyApi,
    promptForExportPasswordSetup,
    confirmAction,
    showSuccess,
    showError,
    showInfo
} = require('./lib/ui/prompts');
const {
    launchClaudeDefault,
    launchClaudeSkipPermissions,
    launchClaudeWithApi,
    testApiConnection
} = require('./lib/launcher');
const { maskSensitiveData, maskApiToken } = require('./lib/validators');
const fs = require('fs');
const path = require('path');

// Initialize components
const apiManager = new ApiManager();
const menu = new Menu();

// Main menu options - simplified to 6 items
const menuOptions = [
    'Launch Claude Code',
    'Launch Claude Code (Skip Permissions)',
    'Launch Claude Code with 3rd-party API',
    'Launch Claude Code with 3rd-party API (Skip Permissions)',
    '3rd-party API Management',
    'Exit'
];

/**
 * Add new third-party API
 */
async function addNewThirdPartyApi() {
    try {
        // Clean up terminal state
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(false);
            process.stdin.removeAllListeners('data');
            process.stdin.pause();
        }

        const apiData = await promptForThirdPartyApi();

        // Test connection before saving
        console.log('');
        const testResult = await testApiConnection({
            baseUrl: apiData.baseUrl,
            authToken: apiData.authToken
        });

        if (!testResult.success) {
            const proceed = await confirmAction('âš ï¸  Connection test failed. Add anyway?');
            if (!proceed) {
                showInfo('API configuration cancelled');
                await waitForKey('Press any key to return to main menu...');
                return showMenu();
            }
        }

        // Check if this is the first API and no export password is set
        const isFirstApi = apiManager.getApis().length === 0;
        const hasExportPassword = apiManager.hasExportPassword();

        const newApi = apiManager.addApi(
            apiData.baseUrl,
            apiData.authToken,
            apiData.model,
            apiData.name,
            apiData.provider
        );

        showSuccess('Third-party API added successfully!', [
            `Name: ${newApi.name}`,
            `Provider: ${newApi.provider}`,
            `Base URL: ${newApi.baseUrl}`,
            `Model: ${newApi.model}`
        ]);

        if (isFirstApi) {
            showInfo('This is your first API - it has been set as active');

            // Prompt for export password setup on first API
            if (!hasExportPassword) {
                const exportPassword = await promptForExportPasswordSetup();
                if (exportPassword) {
                    apiManager.setExportPassword(exportPassword);
                }
            }
        }

    } catch (error) {
        showError('Failed to add API', [error.message]);
    }

    await waitForKey('Press any key to continue...');
}

/**
 * Remove third-party API
 */
async function removeThirdPartyApi() {
    try {
        const apis = apiManager.getApis();

        if (apis.length === 0) {
            showInfo('No third-party APIs configured', [
                'Please add an API first using "Add New 3rd-party API"'
            ]);
            await waitForKey('Press any key to return to main menu...');
            return showMenu();
        }

        const activeApi = apiManager.getActiveApi();
        const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

        const listItems = apis.map(api => {
            // Decrypt and mask the API token for display
            const { decrypt } = require('./lib/crypto');
            let maskedToken;

            try {
                // All stored tokens are encrypted, decrypt for display
                const decrypted = decrypt(api.authToken);
                if (decrypted.success) {
                    maskedToken = maskApiToken(decrypted.value);
                } else {
                    maskedToken = '***DECRYPT_ERROR***';
                }
            } catch (error) {
                console.error('Error decrypting token:', error);
                maskedToken = '***ERROR***';
            }

            return {
                name: api.name,
                details: [
                    `Provider: ${api.provider}`,
                    `Base URL: ${api.baseUrl}`,
                    `Model: ${api.model}`,
                    `API Token: ${maskedToken}`
                ]
            };
        });

        const selectedIndex = await menu.selectFromList('Remove 3rd-party API', listItems, activeIndex);

        if (selectedIndex === null) {
            return showMenu();
        }

        const apiToRemove = apis[selectedIndex];

        console.clear();
        console.log('');
        console.log(colors.bright + colors.orange + 'âš ï¸  Confirm Removal' + colors.reset);
        console.log('');
        showInfo(`API to remove: ${apiToRemove.name}`, [
            `Base URL: ${apiToRemove.baseUrl}`,
            `Model: ${apiToRemove.model}`
        ]);

        console.log(colors.red + 'âš ï¸  This action cannot be undone!' + colors.reset);
        console.log('');

        const confirmed = await confirmAction('Are you sure you want to remove this API?');

        if (confirmed) {
            apiManager.removeApi(selectedIndex);
            showSuccess('API removed successfully!');
        } else {
            showInfo('Removal cancelled');
        }

    } catch (error) {
        showError('Failed to remove API', [error.message]);
    }

    await waitForKey('Press any key to continue...');
}

/**
 * Switch active third-party API
 */
async function switchThirdPartyApi() {
    try {
        const apis = apiManager.getApis();

        if (apis.length === 0) {
            showInfo('No third-party APIs configured', [
                'Please add an API first using "Add New 3rd-party API"'
            ]);
            await waitForKey('Press any key to return to main menu...');
            return showMenu();
        }

        const activeApi = apiManager.getActiveApi();
        const activeIndex = activeApi ? apis.findIndex(api => api.id === activeApi.id) : -1;

        const listItems = apis.map(api => {
            // Decrypt and mask the API token for display
            const { decrypt } = require('./lib/crypto');
            let maskedToken;

            try {
                // All stored tokens are encrypted, decrypt for display
                const decrypted = decrypt(api.authToken);
                if (decrypted.success) {
                    maskedToken = maskApiToken(decrypted.value);
                } else {
                    maskedToken = '***DECRYPT_ERROR***';
                }
            } catch (error) {
                console.error('Error decrypting token:', error);
                maskedToken = '***ERROR***';
            }

            return {
                name: api.name,
                details: [
                    `Provider: ${api.provider}`,
                    `Base URL: ${api.baseUrl}`,
                    `Model: ${api.model}`,
                    `API Token: ${maskedToken}`,
                    `Last Used: ${api.lastUsed || 'Never'}`,
                    `Usage Count: ${api.usageCount || 0}`
                ]
            };
        });

        const selectedIndex = await menu.selectFromList('Switch 3rd-party API', listItems, activeIndex);

        if (selectedIndex === null) {
            return showMenu();
        }

        const selectedApi = apiManager.setActiveApi(selectedIndex);

        console.clear();
        showSuccess('API switched successfully!', [
            `Active API: ${selectedApi.name}`,
            `Provider: ${selectedApi.provider}`,
            `Base URL: ${selectedApi.baseUrl}`,
            `Model: ${selectedApi.model}`
        ]);

    } catch (error) {
        showError('Failed to switch API', [error.message]);
    }

    await waitForKey('Press any key to continue...');
}

/**
 * View API statistics
 */
async function viewStatistics() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'ðŸ“Š API Statistics' + colors.reset);
    console.log('');

    const stats = apiManager.getStatistics();
    const apis = apiManager.getApis();

    console.log(colors.cyan + '  Summary:' + colors.reset);
    console.log(colors.gray + `    Total APIs: ${stats.totalApis}` + colors.reset);
    console.log(colors.gray + `    Active API: ${stats.activeApiName}` + colors.reset);
    console.log(colors.gray + `    Most Used: ${stats.mostUsedApi}` + colors.reset);
    console.log(colors.gray + `    Total Usage: ${stats.totalUsage}` + colors.reset);
    console.log('');

    if (apis.length > 0) {
        console.log(colors.cyan + '  Configured APIs:' + colors.reset);
        apis.forEach((api, index) => {
            const isActive = apiManager.getActiveApi()?.id === api.id;
            console.log(colors.gray + `    ${index + 1}. ${api.name}${isActive ? ' (ACTIVE)' : ''}` + colors.reset);
            console.log(colors.dim + `       Provider: ${api.provider}` + colors.reset);
            console.log(colors.dim + `       Usage: ${api.usageCount || 0} times` + colors.reset);
            console.log(colors.dim + `       Created: ${api.createdAt}` + colors.reset);
        });
    }

    console.log('');
    await waitForKey('Press any key to continue...');
}

/**
 * Show API Management Menu
 */
async function showApiManagementMenu() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'ðŸ“‹ 3rd-party API Management' + colors.reset);
    console.log('');

    const apiManagementMenu = new Menu();
    apiManagementMenu.setOptions([
        'Add New API',
        'Remove API',
        'Switch Active API',
        'View API Statistics',
        'Export Configuration',
        'Import Configuration',
        'Export Password Settings',
        'Back to Main Menu'
    ]);

    const choice = await apiManagementMenu.navigate();

    switch (choice) {
        case 0: // Add New API
            await addNewThirdPartyApi();
            break;

        case 1: // Remove API
            await removeThirdPartyApi();
            break;

        case 2: // Switch Active API
            await switchThirdPartyApi();
            break;

        case 3: // View API Statistics
            await viewStatistics();
            break;

        case 4: // Export Configuration
            await exportConfiguration();
            break;

        case 5: // Import Configuration
            await importConfiguration();
            break;

        case 6: // Export Password Settings
            await manageExportPassword();
            break;

        case 7: // Back to Main Menu
        default:
            showMenu();
            return;
    }

    // Return to API management menu after completing action
    showApiManagementMenu();
}

/**
 * Handle third-party API launch
 */
async function handleThirdPartyApiLaunch(skipPermissions = false) {
    try {
        const activeApi = apiManager.getActiveApi();

        if (!activeApi) {
            console.clear();
            showInfo('No Active Third-party API', [
                'No third-party API is currently active.',
                'Please add and configure an API first, or switch to an existing one.'
            ]);

            await waitForKey('Press any key to return to main menu...');
            return showMenu();
        }

        launchClaudeWithApi(activeApi, skipPermissions);

    } catch (error) {
        showError('Failed to launch with third-party API', [error.message]);

        setTimeout(() => {
            showMenu();
        }, 2000);
    }
}

/**
 * Execute selected menu item
 */
async function executeSelection(selectedIndex) {
    switch (selectedIndex) {
        case 0: // Launch Claude Code
            launchClaudeDefault();
            break;

        case 1: // Launch Claude Code (Skip Permissions)
            launchClaudeSkipPermissions();
            break;

        case 2: // Launch Claude Code with 3rd-party API
            await handleThirdPartyApiLaunch(false);
            break;

        case 3: // Launch Claude Code with 3rd-party API (Skip Permissions)
            await handleThirdPartyApiLaunch(true);
            break;

        case 4: // 3rd-party API Management
            await showApiManagementMenu();
            break;

        case 5: // Exit
            console.log('');
            console.log(colors.green + 'ðŸ‘‹ Goodbye!' + colors.reset);
            process.exit(0);
            break;

        default:
            showMenu();
            break;
    }
}

/**
 * Show main menu
 */
async function showMenu() {
    menu.setOptions(menuOptions);
    const selection = await menu.navigate();

    if (selection === -1) {
        console.log('');
        console.log(colors.green + 'ðŸ‘‹ Goodbye!' + colors.reset);
        process.exit(0);
    } else {
        await executeSelection(selection);
    }
}

/**
 * Manage export password settings
 */
async function manageExportPassword() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'ðŸ”‘ Export Password Settings' + colors.reset);
    console.log('');

    const hasPassword = apiManager.hasExportPassword();

    console.log(colors.cyan + `Current Status: ${hasPassword ? '[Password Set âœ“]' : '[No Password Set âœ—]'}` + colors.reset);
    console.log('');

    const passwordMenu = new Menu();
    const menuOptions = [];

    if (!hasPassword) {
        menuOptions.push('Set Export Password (First Time)');
    } else {
        menuOptions.push('Change Export Password');
        menuOptions.push('Remove Export Password (Disable Export)');
        menuOptions.push('Test Password (Verify Current Password)');
    }
    menuOptions.push('Back to API Management');

    passwordMenu.setOptions(menuOptions);

    if (hasPassword) {
        console.log(colors.yellow + 'âš ï¸  WARNING: Changing or removing password will make existing' + colors.reset);
        console.log(colors.yellow + '    export files inaccessible with the new settings.' + colors.reset);
        console.log('');
    }

    const choice = await passwordMenu.navigate();

    // Handle menu selection based on current state
    const actualChoice = !hasPassword ? choice : choice;

    switch (actualChoice) {
        case 0: // Set/Change Export Password
            await setOrChangeExportPassword(!hasPassword);
            break;

        case 1: // Remove Password or Back (depending on state)
            if (hasPassword) {
                await removeExportPassword();
            }
            break;

        case 2: // Test Password or Back (depending on state)
            if (hasPassword) {
                await testExportPassword();
            }
            break;

        case 3: // Back (only when has password)
        default:
            return; // Direct return without waiting for key
    }

    await waitForKey('Press any key to continue...');
}

/**
 * Set or change export password
 */
async function setOrChangeExportPassword(isFirstTime) {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + (isFirstTime ? 'ðŸ”‘ Set Export Password' : 'ðŸ”‘ Change Export Password') + colors.reset);
    console.log('');

    // Show detailed warning
    console.log(colors.yellow + 'ðŸš¨ CRITICAL WARNING:' + colors.reset);
    console.log(colors.red + '   â€¢ If you forget your export password, it CANNOT be recovered' + colors.reset);
    console.log(colors.red + '   â€¢ You will lose access to all exported configuration files' + colors.reset);
    console.log(colors.red + '   â€¢ You\'ll need to manually reconfigure APIs on new machines' + colors.reset);
    console.log(colors.red + '   â€¢ Choose a password you can remember or store securely' + colors.reset);
    console.log('');

    console.log(colors.cyan + 'ðŸ“ Password Requirements:' + colors.reset);
    console.log(colors.gray + '   â€¢ Minimum 8 characters recommended' + colors.reset);
    console.log(colors.gray + '   â€¢ Mix of letters, numbers, and symbols preferred' + colors.reset);
    console.log(colors.gray + '   â€¢ Store this password in a safe place (password manager)' + colors.reset);
    console.log('');

    if (!isFirstTime) {
        // Verify current password first
        const currentPassword = await simpleInput(colors.green + '[>] Enter current export password: ' + colors.reset);
        if (!apiManager.verifyExportPassword(currentPassword)) {
            showError('Current password verification failed');
            return;
        }
    }

    // Get new password
    const newPassword = await simpleInput(colors.green + '[>] Enter new export password: ' + colors.reset);
    if (newPassword.length < 8) {
        showError('Password should be at least 8 characters');
        return;
    }

    const confirmPassword = await simpleInput(colors.green + '[>] Confirm new password: ' + colors.reset);
    if (newPassword !== confirmPassword) {
        showError('Passwords do not match');
        return;
    }

    try {
        apiManager.setExportPassword(newPassword);
        showSuccess(isFirstTime ? 'Export password set successfully!' : 'Export password changed successfully!', [
            'You can now use export/import features',
            'âš ï¸  Remember: This password cannot be recovered if forgotten'
        ]);
    } catch (error) {
        showError('Failed to set export password', [error.message]);
    }
}

/**
 * Remove export password
 */
async function removeExportPassword() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.red + 'âš ï¸  Remove Export Password' + colors.reset);
    console.log('');

    console.log(colors.red + 'ðŸš¨ WARNING: This will:' + colors.reset);
    console.log(colors.gray + '   â€¢ Disable export/import functionality' + colors.reset);
    console.log(colors.gray + '   â€¢ Make existing export files unusable' + colors.reset);
    console.log(colors.gray + '   â€¢ Cannot be undone without setting a new password' + colors.reset);
    console.log('');

    const confirmed = await confirmAction('Are you sure you want to remove the export password?');
    if (!confirmed) {
        showInfo('Export password removal cancelled');
        return;
    }

    // Verify current password
    const currentPassword = await simpleInput(colors.green + '[>] Enter current export password to confirm: ' + colors.reset);
    if (!apiManager.verifyExportPassword(currentPassword)) {
        showError('Password verification failed - removal cancelled');
        return;
    }

    try {
        apiManager.removeExportPassword();
        showSuccess('Export password removed successfully!', [
            'Export/import features are now disabled',
            'You can set a new password anytime to re-enable these features'
        ]);
    } catch (error) {
        showError('Failed to remove export password', [error.message]);
    }
}

/**
 * Test export password
 */
async function testExportPassword() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.cyan + 'ðŸ” Test Export Password' + colors.reset);
    console.log('');

    const password = await simpleInput(colors.green + '[>] Enter export password to verify: ' + colors.reset);

    if (apiManager.verifyExportPassword(password)) {
        showSuccess('Password verification successful!', [
            'Your export password is correct',
            'You can safely use export/import features'
        ]);
    } else {
        showError('Password verification failed', [
            'The entered password is incorrect',
            'Please check your password and try again'
        ]);
    }
}

/**
 * Export configuration with password encryption
 */
async function exportConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'ðŸ’¾ Export Configuration' + colors.reset);
    console.log('');

    if (!apiManager.hasExportPassword()) {
        console.log(colors.red + 'âŒ Export Not Available' + colors.reset);
        console.log('');
        console.log(colors.yellow + 'ðŸ”‘ Export password not set.' + colors.reset);
        console.log('');
        console.log(colors.gray + 'To use export/import features:' + colors.reset);
        console.log(colors.gray + '1. Go to "Export Password Settings"' + colors.reset);
        console.log(colors.gray + '2. Set an export password' + colors.reset);
        console.log(colors.gray + '3. Return here to export your configuration' + colors.reset);
        console.log('');
        console.log(colors.yellow + 'âš ï¸  Without export password:' + colors.reset);
        console.log(colors.gray + '   â€¢ Configuration backup is not available' + colors.reset);
        console.log(colors.gray + '   â€¢ Cannot transfer settings to other machines' + colors.reset);
        console.log(colors.gray + '   â€¢ APIs remain secure with local-only encryption' + colors.reset);
        console.log('');

        const exportMenu = new Menu();
        exportMenu.setOptions([
            'Set Export Password Now',
            'Back to API Management Menu'
        ]);

        const choice = await exportMenu.navigate();
        if (choice === 0) {
            await setOrChangeExportPassword(true);
        }
        return;
    }

    const apis = apiManager.getApis();
    if (apis.length === 0) {
        showInfo('No APIs configured', ['Please add at least one API before exporting']);
        await waitForKey('Press any key to continue...');
        return;
    }

    // Show security reminder
    console.log(colors.cyan + `Current Status: [Export Password: Set âœ“]` + colors.reset);
    console.log('');
    console.log(colors.yellow + 'âš ï¸  Security Reminder:' + colors.reset);
    console.log(colors.gray + '   â€¢ Export files contain your API keys encrypted with export password' + colors.reset);
    console.log(colors.gray + '   â€¢ Keep export files secure - they contain sensitive information' + colors.reset);
    console.log(colors.gray + '   â€¢ Export password cannot be recovered if forgotten' + colors.reset);
    console.log('');

    console.log(colors.cyan + 'Export Options:' + colors.reset);
    console.log(colors.gray + '1. Export All APIs (Recommended)' + colors.reset);
    console.log(colors.gray + '2. Export Selected APIs' + colors.reset);
    console.log(colors.gray + '3. Export Configuration Structure Only (No API Keys)' + colors.reset);
    console.log('');

    const option = await simpleInput(colors.green + '[>] Choose option (1-3): ' + colors.reset);

    // Verify export password
    const password = await simpleInput(colors.green + '[>] Enter export password: ' + colors.reset);
    if (!apiManager.verifyExportPassword(password)) {
        showError('Export password verification failed');
        return;
    }

    try {
        const filename = `claude-launcher-backup-${Date.now()}-encrypted.json`;
        const filepath = path.join(process.cwd(), filename);

        let exportData;
        switch (option) {
            case '1':
                exportData = apiManager.exportConfigWithPassword(password);
                break;
            case '2':
                // TODO: Implement selective export
                showInfo('Selective export feature coming soon');
                return;
            case '3':
                exportData = apiManager.exportConfigStructureOnly();
                break;
            default:
                showError('Invalid option selected');
                return;
        }

        fs.writeFileSync(filepath, exportData);
        showSuccess('Configuration exported successfully!', [
            `ðŸ“ File: ${filename}`,
            'ðŸ”’ Encryption: AES-256 with your export password',
            'ðŸ’¾ Location: Current directory'
        ]);

    } catch (error) {
        showError('Export failed', [error.message]);
    }

    await waitForKey('Press any key to continue...');
}

/**
 * Import configuration with password decryption
 */
async function importConfiguration() {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.orange + 'ðŸ“¥ Import Configuration' + colors.reset);
    console.log('');

    // Check if export password is set
    if (!apiManager.hasExportPassword()) {
        console.log(colors.red + 'âŒ Import Not Available' + colors.reset);
        console.log('');
        console.log(colors.yellow + 'ðŸ”‘ Export password not set.' + colors.reset);
        console.log('');
        console.log(colors.gray + 'To use import functionality:' + colors.reset);
        console.log(colors.gray + '1. Set an export password first' + colors.reset);
        console.log(colors.gray + '2. Import requires the same password that was used for export' + colors.reset);
        console.log('');

        const importMenu = new Menu();
        importMenu.setOptions([
            'Set Export Password Now',
            'Back to API Management Menu'
        ]);

        const choice = await importMenu.navigate();
        if (choice === 0) {
            await setOrChangeExportPassword(true);
        }
        return;
    }

    console.log(colors.yellow + 'âš ï¸  Import Warning:' + colors.reset);
    console.log(colors.gray + '   â€¢ Importing will merge with existing APIs' + colors.reset);
    console.log(colors.gray + '   â€¢ Duplicates (same URL + Token + Model) will be skipped' + colors.reset);
    console.log(colors.gray + '   â€¢ Original API settings will be preserved for duplicates' + colors.reset);
    console.log('');

    console.log(colors.cyan + 'ðŸ“ Import Methods:' + colors.reset);
    console.log(colors.gray + '1. Auto-detect files in current directory' + colors.reset);
    console.log(colors.gray + '2. Enter JSON file path manually' + colors.reset);
    console.log('');

    const methodChoice = await simpleInput(colors.green + '[>] Choose import method (1-2): ' + colors.reset);

    let filePath;
    let isEncrypted;

    if (methodChoice === '1') {
        // Auto-detect method
        try {
            const files = fs.readdirSync(process.cwd())
                .filter(f => f.startsWith('claude-launcher-backup-') && f.endsWith('.json'))
                .sort((a, b) => b.localeCompare(a)); // Sort by newest first

            if (files.length === 0) {
                showError('No backup files found in current directory', [
                    'Please place your backup file in the current directory',
                    'File name should start with "claude-launcher-backup-"'
                ]);
                await waitForKey('Press any key to continue...');
                return;
            }

            console.log('');
            console.log(colors.cyan + 'Detected files:' + colors.reset);
            files.forEach((f, i) => {
                const fileEncrypted = f.includes('encrypted');
                const icon = fileEncrypted ? 'ðŸ”’' : 'ðŸ“„';
                const status = fileEncrypted ? '(Encrypted)' : '(Plain)';
                console.log(colors.gray + `  ${i + 1}. ${icon} ${f} ${status}` + colors.reset);
            });
            console.log('');

            const fileChoice = await simpleInput(colors.green + `[>] Select file (1-${files.length}): ` + colors.reset);
            const fileIndex = parseInt(fileChoice) - 1;

            if (fileIndex < 0 || fileIndex >= files.length) {
                showError('Invalid file selection');
                return;
            }

            const selectedFile = files[fileIndex];
            filePath = path.join(process.cwd(), selectedFile);
            isEncrypted = selectedFile.includes('encrypted');
        } catch (error) {
            showError('Failed to read directory', [error.message]);
            return;
        }
    } else if (methodChoice === '2') {
        // Manual path input
        console.log('');
        const inputPath = await simpleInput(colors.green + '[>] Enter full path to JSON file: ' + colors.reset);

        if (!inputPath || inputPath.trim() === '') {
            showError('No file path provided');
            return;
        }

        filePath = inputPath.trim();

        // Check if file exists
        if (!fs.existsSync(filePath)) {
            showError('File not found', [`Path: ${filePath}`]);
            return;
        }

        // Check if it's a JSON file
        if (!filePath.toLowerCase().endsWith('.json')) {
            showError('File must be a JSON file', [`Path: ${filePath}`]);
            return;
        }

        // Try to determine if encrypted by checking filename or content
        isEncrypted = path.basename(filePath).includes('encrypted');
    } else {
        showError('Invalid method selection');
        return;
    }

    try {
        // Read and validate JSON file
        const fileContent = fs.readFileSync(filePath, 'utf8');
        let configData;

        // Try to parse as JSON first to validate format
        try {
            const jsonTest = JSON.parse(fileContent);
            // Check if it might be encrypted by looking for encrypted field
            if (jsonTest.encrypted === true) {
                isEncrypted = true;
            }
        } catch (error) {
            showError('Invalid JSON file format', [
                'File is not a valid JSON file',
                error.message
            ]);
            return;
        }

        if (isEncrypted) {
            console.log('');
            console.log(colors.yellow + 'ðŸ”‘ Password Required:' + colors.reset);
            const password = await simpleInput(colors.green + '[>] Enter export password: ' + colors.reset);

            try {
                configData = apiManager.importConfigWithPassword(fileContent, password);
            } catch (error) {
                showError('Failed to decrypt configuration file', [
                    'Please check your export password',
                    error.message
                ]);
                return;
            }
        } else {
            try {
                configData = JSON.parse(fileContent);

                // Validate configuration structure
                if (!configData.apis || !Array.isArray(configData.apis)) {
                    showError('Invalid configuration file', [
                        'Configuration file does not contain valid API data',
                        'Expected: JSON object with "apis" array'
                    ]);
                    return;
                }
            } catch (error) {
                showError('Invalid configuration file format', [error.message]);
                return;
            }
        }

        // Show import options
        console.log('');
        console.log(colors.cyan + 'Import Options:' + colors.reset);
        console.log(colors.gray + '1. Import All APIs' + colors.reset);
        console.log(colors.gray + '2. Preview APIs (Show what will be imported)' + colors.reset);
        console.log(colors.gray + '3. Select Specific APIs' + colors.reset);
        console.log(colors.gray + '4. Cancel Import' + colors.reset);
        console.log('');

        const importOption = await simpleInput(colors.green + '[>] Choose option (1-4): ' + colors.reset);

        switch (importOption) {
            case '1':
                await performImport(configData);
                break;
            case '2':
                await previewImport(configData);
                break;
            case '3':
                showInfo('Selective import feature coming soon');
                break;
            case '4':
            default:
                showInfo('Import cancelled');
                break;
        }

    } catch (error) {
        showError('Import failed', [error.message]);
    }

    await waitForKey('Press any key to continue...');
}

/**
 * Perform the actual import of configuration
 */
async function performImport(configData) {
    try {
        const result = apiManager.importConfig(configData);
        showSuccess('Configuration imported successfully!', [
            `Imported ${result.imported} APIs`,
            `Skipped ${result.skipped} duplicates`,
            `Total APIs: ${apiManager.getApis().length}`
        ]);
    } catch (error) {
        showError('Import failed', [error.message]);
    }
}

/**
 * Preview what will be imported
 */
async function previewImport(configData) {
    console.clear();
    console.log('');
    console.log(colors.bright + colors.cyan + 'ðŸ‘ï¸  Import Preview' + colors.reset);
    console.log('');

    if (!configData.apis || configData.apis.length === 0) {
        showInfo('No APIs found in configuration file');
        return;
    }

    console.log(colors.cyan + `Found ${configData.apis.length} API(s) in backup:` + colors.reset);
    console.log('');

    configData.apis.forEach((api, index) => {
        // Use the same duplicate check logic as import
        const importToken = api.authToken === '***REQUIRES_MANUAL_INPUT***' ? '' : api.authToken;
        const duplicate = apiManager.checkDuplicate(api.baseUrl, importToken, api.model);

        const status = duplicate.isDuplicate ? '(Will be skipped - duplicate config)' : '(Will be imported)';
        const statusColor = duplicate.isDuplicate ? colors.yellow : colors.green;

        console.log(colors.gray + `  ${index + 1}. ${api.name || 'Unnamed API'}` + colors.reset);
        console.log(colors.dim + `     Provider: ${api.provider || 'Unknown'}` + colors.reset);
        console.log(colors.dim + `     Base URL: ${api.baseUrl}` + colors.reset);
        console.log(colors.dim + `     Model: ${api.model || 'Unknown'}` + colors.reset);
        console.log(statusColor + `     Status: ${status}` + colors.reset);
        console.log('');
    });

    const confirmed = await confirmAction('Proceed with import?');
    if (confirmed) {
        await performImport(configData);
    } else {
        showInfo('Import cancelled');
    }
}

/**
 * Handle process termination
 */
process.on('SIGINT', () => {
    console.log('');
    console.log(colors.green + 'ðŸ‘‹ Goodbye!' + colors.reset);
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('');
    console.log(colors.green + 'ðŸ‘‹ Goodbye!' + colors.reset);
    process.exit(0);
});

// Start the application
console.log(colors.dim + 'Claude Launcher v2.0.0 - Modular Edition' + colors.reset);
showMenu();